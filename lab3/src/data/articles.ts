export type Article = {
  id: number
  title: string
  excerpt: string
  date: string
  image: string
  content: string
  status?: "draft" | "published"
}

export const articles: Article[] = [
  {
    id: 1,
    title: "Zero Trust на практиці: з чого почати без оверхеду",
    excerpt: "Мінімальний набір кроків: ідентифікація, сегментація, контроль доступу та аудит.",
    date: "2025-12-15",
    image: "https://picsum.photos/seed/sec1/900/500",
    content:
      "Zero Trust — це не про «купити один продукт», а про зміну моделі довіри: за замовчуванням не довіряємо нічому, навіть внутрішній мережі. Почни з інвентаризації сервісів і потоків трафіку: які системи з ким говорять, які порти й протоколи реально потрібні.\n\nДалі — мінімальна сегментація. Навіть простий поділ на зони (edge, app, data, admin) вже дає ефект. На цьому кроці важливо не ламати бізнес: додавай правила поступово, спираючись на логи (NetFlow, conntrack, security events) і перехідні allow-листи.\n\nТретій шар — контроль ідентичностей. Для адмін-доступу: MFA, короткоживучі токени/сертифікати, чіткі ролі, JIT/JEA де можливо. І останнє: аудит. Якщо подію неможливо відтворити по логах — це не контроль, а ілюзія контролю.",
    status: "published",
  },
  {
    id: 2,
    title: "Rate limiting на вході: Nginx, WAF і здравий глузд",
    excerpt: "Як захиститись від простих DDoS/абʼюзу без того, щоб забанити нормальних користувачів.",
    date: "2025-12-14",
    image: "https://picsum.photos/seed/sec2/900/500",
    content:
      "Найчастіша помилка — увімкнути жорсткий ліміт «для всіх» і отримати хвилю скарг від реальних користувачів. Правильніше починати з вимірювання: які endpoints найчастіше б’ють, який відсоток 4xx/5xx, скільки запитів на IP/сесію на піку.\n\nУ Nginx базово достатньо `limit_req` і `limit_conn`, але ключ у деталях: різні ліміти для login, search та статичних ресурсів. Плюс винятки для trusted IP/ASN, якщо це корпоративні інтеграції. Обов’язково логуй відсічення (status 429) окремо — це допоможе відтюнити пороги.\n\nWAF доречний, коли потрібні правила рівня застосунку: блокувати типові патерни інʼєкцій, ботів, а також робити challenge/JS. Але WAF не замінює нормальне кешування, CDN і грамотні таймаути — це все частини одного дизайну захисту.",
    status: "published",
  },
  {
    id: 3,
    title: "Бекапи, які реально відновлюються: 3-2-1 і тестові рестори",
    excerpt: "Чому «бекап є» нічого не означає без регулярної перевірки відновлення.",
    date: "2025-12-13",
    image: "https://picsum.photos/seed/sec3/900/500",
    content:
      "Більшість інцидентів болять не через відсутність бекапів, а через те, що їх ніхто не перевіряв. Правило 3-2-1 — мінімум: три копії даних, дві різні технології зберігання, одна копія — офсайт. Але навіть це не гарантія, якщо restore-процес не автоматизований і не документований.\n\nНормальна практика — мати «restore runbook» і регулярний тестовий рестор у staging/ізольоване середовище. Для баз даних: перевіряти не лише факт відновлення файлів, а консистентність даних, права, міграції, час відновлення (RTO) і максимально допустиму втрату даних (RPO).\n\nЯкщо дані критичні — розділяй бекапи на гарячі (швидке відновлення) і архівні (довге зберігання). І не забувай про секрети: ключі шифрування, паролі, KMS — без них бекап може бути «ідеальним», але марним.",
    status: "draft",
  },
  {
    id: 4,
    title: "Observability без хаосу: логи, метрики, трейси — що і коли потрібно",
    excerpt: "Як не потонути в даних і зібрати сигнал, який реально допомагає в інцидентах.",
    date: "2025-12-12",
    image: "https://picsum.photos/seed/sec4/900/500",
    content:
      "Починай з метрик, бо вони дають швидку відповідь «що зламалось»: latency, error rate, saturation (CPU/RAM/IO), queue depth. Далі — логи для контексту: ідентифікатори запитів, статуси, причина помилки, ключові бізнес-події. Трейси стають критичними, коли система розподілена і треба зрозуміти, де саме виникає затримка.\n\nТипова пастка — збирати все підряд. Краще визначити SLO/SLI: що означає “сервіс працює добре” і які сигнали це відображають. Після цього роби алерти по симптомах, а не по причинах: «ріст 5xx» важливіший за «CPU 80%», бо CPU може бути нормальним під навантаженням.\n\nОкремо продумай кореляцію: traceId/requestId має проходити від edge до бази. Без цього інцидент перетворюється на детектив, де кожен лог — окрема історія без зв’язків.",
    status: "draft",
  },
  {
    id: 5,
    title: "Secrets management: .env — це не сховище, а тимчасовий компроміс",
    excerpt: "Як зменшити ризики витоку секретів і нормально організувати ротацію ключів.",
    date: "2025-12-11",
    image: "https://picsum.photos/seed/sec5/900/500",
    content:
      "Файли `.env` зручні на старті, але погано масштабується: важко контролювати доступ, ротацію і аудит. Перша сходинка — прибрати секрети з репозиторію назавжди: git history теж секретосховище, якщо одного разу «випадково» закомітили ключ.\n\nДалі — централізація: Vault/KMS/Secret Manager (залежно від стеку) або хоча б Docker/Kubernetes secrets з обмеженням доступу на рівні сервісних акаунтів. Секрети мають бути короткоживучими, а не «вічними» — тоді компрометація одного токена не стає катастрофою.\n\nНарешті — ротація як процес. Якщо ключі не ротуються автоматично або хоча б по чіткому регламенту, це відкладена проблема. Плюс: логування доступу до секретів і алерти на аномалії — без цього інцидент буде видно вже постфактум.",
    status: "draft",
  },
  {
    id: 5,
    title: "Secrets management: .env — це не сховище, а тимчасовий компроміс",
    excerpt: "Як зменшити ризики витоку секретів і нормально організувати ротацію ключів.",
    date: "2025-12-11",
    image: "https://picsum.photos/seed/sec5/900/500",
    content:
      "Файли `.env` зручні на старті, але погано масштабується: важко контролювати доступ, ротацію і аудит. Перша сходинка — прибрати секрети з репозиторію назавжди: git history теж секретосховище, якщо одного разу «випадково» закомітили ключ.\n\nДалі — централізація: Vault/KMS/Secret Manager (залежно від стеку) або хоча б Docker/Kubernetes secrets з обмеженням доступу на рівні сервісних акаунтів. Секрети мають бути короткоживучими, а не «вічними» — тоді компрометація одного токена не стає катастрофою.\n\nНарешті — ротація як процес. Якщо ключі не ротуються автоматично або хоча б по чіткому регламенту, це відкладена проблема. Плюс: логування доступу до секретів і алерти на аномалії — без цього інцидент буде видно вже постфактум.",
    status: "draft",
  },
  {
    id: 5,
    title: "Secrets management: .env — це не сховище, а тимчасовий компроміс",
    excerpt: "Як зменшити ризики витоку секретів і нормально організувати ротацію ключів.",
    date: "2025-12-11",
    image: "https://picsum.photos/seed/sec5/900/500",
    content:
      "Файли `.env` зручні на старті, але погано масштабується: важко контролювати доступ, ротацію і аудит. Перша сходинка — прибрати секрети з репозиторію назавжди: git history теж секретосховище, якщо одного разу «випадково» закомітили ключ.\n\nДалі — централізація: Vault/KMS/Secret Manager (залежно від стеку) або хоча б Docker/Kubernetes secrets з обмеженням доступу на рівні сервісних акаунтів. Секрети мають бути короткоживучими, а не «вічними» — тоді компрометація одного токена не стає катастрофою.\n\nНарешті — ротація як процес. Якщо ключі не ротуються автоматично або хоча б по чіткому регламенту, це відкладена проблема. Плюс: логування доступу до секретів і алерти на аномалії — без цього інцидент буде видно вже постфактум.",
    status: "draft",
  },
  {
    id: 5,
    title: "Secrets management: .env — це не сховище, а тимчасовий компроміс",
    excerpt: "Як зменшити ризики витоку секретів і нормально організувати ротацію ключів.",
    date: "2025-12-11",
    image: "https://picsum.photos/seed/sec5/900/500",
    content:
      "Файли `.env` зручні на старті, але погано масштабується: важко контролювати доступ, ротацію і аудит. Перша сходинка — прибрати секрети з репозиторію назавжди: git history теж секретосховище, якщо одного разу «випадково» закомітили ключ.\n\nДалі — централізація: Vault/KMS/Secret Manager (залежно від стеку) або хоча б Docker/Kubernetes secrets з обмеженням доступу на рівні сервісних акаунтів. Секрети мають бути короткоживучими, а не «вічними» — тоді компрометація одного токена не стає катастрофою.\n\nНарешті — ротація як процес. Якщо ключі не ротуються автоматично або хоча б по чіткому регламенту, це відкладена проблема. Плюс: логування доступу до секретів і алерти на аномалії — без цього інцидент буде видно вже постфактум.",
    status: "draft",
  },
  {
    id: 5,
    title: "Secrets management: .env — це не сховище, а тимчасовий компроміс",
    excerpt: "Як зменшити ризики витоку секретів і нормально організувати ротацію ключів.",
    date: "2025-12-11",
    image: "https://picsum.photos/seed/sec5/900/500",
    content:
      "Файли `.env` зручні на старті, але погано масштабується: важко контролювати доступ, ротацію і аудит. Перша сходинка — прибрати секрети з репозиторію назавжди: git history теж секретосховище, якщо одного разу «випадково» закомітили ключ.\n\nДалі — централізація: Vault/KMS/Secret Manager (залежно від стеку) або хоча б Docker/Kubernetes secrets з обмеженням доступу на рівні сервісних акаунтів. Секрети мають бути короткоживучими, а не «вічними» — тоді компрометація одного токена не стає катастрофою.\n\nНарешті — ротація як процес. Якщо ключі не ротуються автоматично або хоча б по чіткому регламенту, це відкладена проблема. Плюс: логування доступу до секретів і алерти на аномалії — без цього інцидент буде видно вже постфактум.",
    status: "draft",
  },
  {
    id: 5,
    title: "Secrets management: .env — це не сховище, а тимчасовий компроміс",
    excerpt: "Як зменшити ризики витоку секретів і нормально організувати ротацію ключів.",
    date: "2025-12-11",
    image: "https://picsum.photos/seed/sec5/900/500",
    content:
      "Файли `.env` зручні на старті, але погано масштабується: важко контролювати доступ, ротацію і аудит. Перша сходинка — прибрати секрети з репозиторію назавжди: git history теж секретосховище, якщо одного разу «випадково» закомітили ключ.\n\nДалі — централізація: Vault/KMS/Secret Manager (залежно від стеку) або хоча б Docker/Kubernetes secrets з обмеженням доступу на рівні сервісних акаунтів. Секрети мають бути короткоживучими, а не «вічними» — тоді компрометація одного токена не стає катастрофою.\n\nНарешті — ротація як процес. Якщо ключі не ротуються автоматично або хоча б по чіткому регламенту, це відкладена проблема. Плюс: логування доступу до секретів і алерти на аномалії — без цього інцидент буде видно вже постфактум.",
    status: "draft",
  },
]

